# masters/models.py
from django.db import models

class EmployeeType(models.Model):
    name = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name


class BrandType(models.Model):
    name = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
    
class EmployeeRolles(models.Model):
    name = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
class vendortype(models.Model):
    name = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
class Item(models.Model):  # Class names should follow PascalCase convention
    name = models.CharField(max_length=255)
    brand = models.ForeignKey(  # Assuming `BrandType` is another model
        BrandType, on_delete=models.CASCADE, related_name='items'  # Use plural for related_name
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        # Check if brand exists to avoid potential issues when a related object is deleted
        return f"{self.name} ({self.brand.name})" if self.brand else self.name
